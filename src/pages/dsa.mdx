import { Tag } from '../components/Tag'

export const description =
  'In this section we will review 14 major patterns and problems used in Data Structures and Algorithms. We will also review the most common solutions to these problems and their time and space complexity.'

# Data Structures and Algorithms

In this section we will review 14 major patterns and problems used in Data Structures and Algorithms. We will also review the most common solutions to these problems and their time and space complexity.

## Table of Contents

- [Sliding Window](#sliding-window)
  - [Maximum sum subarray of size K (easy)](#maximum-sum-subarray-of-size-k-easy)
  - [Longest substring with `K` distinct characters (medium)](#longest-substring-with-k-distinct-characters-medium)
- [Two Pointers](#two-pointers)
  - [Pair with target sum (easy)](#pair-with-target-sum-easy)
  - [Squaring a sorted array (easy)](#squaring-a-sorted-array-easy)
  - [Triplet sum to zero (medium)](#triplet-sum-to-zero-medium)
- [Fast and Slow Pointers](#fast-and-slow-pointers)
  - [Linked List Cycle (easy)](#linked-list-cycle-easy)
  - [Palindrome Linked List (medium)](#palindrome-linked-list-medium)
  - [Middle of the Linked List (easy)](#middle-of-the-linked-list-easy)
- [Merge Intervals](#merge-intervals)
  - [Insert Interval (medium)](#insert-interval-medium)
  - [Intervals Intersection (medium)](#intervals-intersection-medium)
  - [Conflicting Appointments (medium)](#conflicting-appointments-medium)
  - [Maximum CPU Load (hard)](#maximum-cpu-load-hard)
- [Cyclic Sort](#cyclic-sort)
  - [Find the Missing Number (easy)](#find-the-missing-number-easy)
  - [Find all Missing Numbers (easy)](#find-all-missing-numbers-easy)
  - [Find the Duplicate Number (easy)](#find-the-duplicate-number-easy)
  - [Find all Duplicate Numbers (easy)](#find-all-duplicate-numbers-easy)
  - [Find the Missing Positive Number (medium)](#find-the-missing-positive-number-medium)
- [In-place Reversal of a LinkedList](#in-place-reversal-of-a-linkedlist)
  - [Reverse a LinkedList (easy)](#reverse-a-linkedlist-easy)
  - [Reverse a Sub-list (medium)](#reverse-a-sub-list-medium)
  - [Reverse every K-element Sub-list (medium)](#reverse-every-k-element-sub-list-medium)
- [Tree Breadth First Search](#tree-breadth-first-search)
  - [Binary Tree Level Order Traversal (easy)](#binary-tree-level-order-traversal-easy)
  - [Reverse Level Order Traversal (easy)](#reverse-level-order-traversal-easy)
  - [Zigzag Traversal (medium)](#zigzag-traversal-medium)
  - [Level Averages in a Binary Tree (easy)](#level-averages-in-a-binary-tree-easy)
  - [Minimum Depth of a Binary Tree (easy)](#minimum-depth-of-a-binary-tree-easy)
  - [Level Order Successor (easy)](#level-order-successor-easy)
  - [Connect Level Order Siblings (medium)](#connect-level-order-siblings-medium)
  - [Connect All Level Order Siblings (medium)](#connect-all-level-order-siblings-medium)
- [Tree Depth First Search](#tree-depth-first-search)
- [Two Heaps](#two-heaps)
- [Subsets](#subsets)
- [Modified Binary Search](#modified-binary-search)

## Sliding Window {{ className: 'text-3xl rounded-md pl-2 bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

A pattern used when given an `array` or `linked list`. Used when we need to perform a required operation on a specific window size.

<Row>
  <Col>

## Maximum sum subarray of size K (easy)

### Description: You have an array of N positive integers and a positive integer `num`. You have to find the Maximum Sum Subarray of size `num`.

</Col>
<Col>

```js
function maxSumSubarray(arr, num) {
  // variables
  let maxSum = 0
  let maxTemporarySum = 0

  // edge cases
  if (arr.length < num) return null

  // first loop
  for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }

  // store the first sum
  maxTemporarySum = maxSum

  // second loop
  for (let i = num; i < arr.length; i++) {
    maxTemporarySum += -arr[i - num] + arr[i]
    maxSum = Math.max(maxSum, maxTemporarySum)
  }

  // return the max sum
  return maxSum
}

console.log(maxSumSubarray([1, 2, 5, 2, 8, 1, 5], 2)) // 10
console.log(maxSumSubarray([1, 2, 5, 2, 8, 1, 5], 4)) // 17
console.log(maxSumSubarray([4, 2, 1, 6], 1)) // 6
console.log(maxSumSubarray([4, 2, 1, 6, 2], 4)) // 13

// Time Complexity: O(n)
// Space Complexity: O(1)
```

</Col>
</Row>

<Row>
  <Col>

## Longest substring with `K` distinct characters (medium)

### Description: Given a string you need to print longest possible substring that has exactly M unique characters. If there is more than one substring of longest possible length, then print any one of them.

Here are the steps we can take in order to solve this using the sliding window technique:

- Setup Variables
- For Loop, rightChar
- if else statement
- While Loop, leftChar
- if else, Incr start
- Calculate Max & return


</Col>
<Col>

```js
var lengthOfLongestSubstringKDistinct = function (s, k) {
  // SETUP VARIABLES
  let START = 0
  const SOFAR = new Map()
  let MAX = 0

  // ITERATE OVER s, our string, set END = 0
  for (let END = 0; END < s.length; END++) {
    // pull out our rightCHAR
    let rightCHAR = s[END]

    // if our Map does not contain the rightCHAR, then we want to set it to 1
    if (!SOFAR.get(rightCHAR)) SOFAR.set(rightCHAR, 1)
    // if it does contain the rightCHAR, then we want to increment it by 1
    else SOFAR.set(rightCHAR, SOFAR.get(rightCHAR) + 1)

    // NOW check the size (# of keys we have in SOFAR) and while it is > k
    // THEN we have to decrement the START and move it to the right one
    while (SOFAR.size > k) {
      // so lets get our leftCHAR which = s[START]
      let leftCHAR = s[START]

      //SO IF > 1 leftCHAR we want to decrement (or DELETE) followed by increment our window START
      if (SOFAR.get(leftCHAR) > 1) SOFAR.set(leftCHAR, SOFAR.get(leftCHAR) - 1)
      else SOFAR.delete(leftCHAR)

      START++
    }
    // calculate MAX using Math.max
    MAX = Math.max(MAX, END - START + 1)
  }
  // return MAX
  return MAX
}

// Test Cases
lengthOfLongestSubstringKDistinct('atatrasrafr', 3) // returns 6
lengthOfLongestSubstringKDistinct('atatrasrafr', 4) // returns 9
```
</Col>
</Row>




## Two Pointers {{ className: 'text-3xl rounded-md pl-2 bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Pair with target sum (easy)

Given an array[1, 2, 3, 4, 6] with target sum:

- pointer1 points to the first element of an array, which is 1
- pointer2 points to the last element, which is 6
- First, 1 + 6 > target sum (6) so let's decrement pointer2
- Now, pointer 2 points to the second to the last element, which is 4
- Second, 1+ 4 < target sum (6) so let's increment pointer1
- Now, pointer 1 points to the second element, which is 2)
- ... so on until finding the pair which has the equal value to the target sum

</Col>
<Col>

```js
function pair_with_target_sum(arr, targetSum) {
  // pointer1 , pointing the first element
  let left = 0
  // pointer2, pointing the last element
  let right = arr.length - 1

  // until two pointers cross each other
  while (left < right) {
    const currentSum = arr[left] + arr[right]
    // returns the index (pointer1, pointer2)
    // if arr[pointer1] + arr[pointer2] == targetSum
    if (currentSum === targetSum) {
      return [left, right]
    }

    // if arr[pointer1] + arr[pointer2] < targetSum
    if (targetSum > currentSum) {
      // increment pointer1
      // we need bigger sum
      left += 1
    } else {
      // increment pointer2
      // we need smaller sum
      right -= 1
    }
  }
  // if not found, return [-1, -1]
  return [-1, -1]
}

console.log(pair_with_target_sum([1, 2, 3, 4, 6], 6))
console.log(pair_with_target_sum([2, 5, 9, 11], 11))
```
</Col>
</Row>

<Row>
  <Col>
## Squaring a sorted array (easy)

Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order.

- First, we can use two pointers to iterate through the array.
- One pointer will iterate from the beginning of the array.
- The other pointer will iterate from the end of the array.
- At any step, whichever number gives us a bigger square will be added to the result array.
- As a result, the array will be sorted in the descending order.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - we are iterating the input array only
  once
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - this space will be used for the
  output array.
</div>

</Col>
<Col>

```js
function make_squares(arr) {
  const n = arr.length // length of the array
  squares = Array(n).fill(0) // create an array of n elements
  let highestSquareIdx = n - 1 // index of the last element
  let left = 0, // index of the first element
    right = n - 1 // index of the last element
  while (left <= right) {
    // while two pointers don't cross each other
    let leftSquare = arr[left] * arr[left], // square of the left element
      rightSquare = arr[right] * arr[right] // square of the right element
    if (leftSquare > rightSquare) {
      // if left square is bigger than right square
      squares[highestSquareIdx] = leftSquare // put the left square in the last index of the result array
      left += 1 // move left pointer to the next element
    } else {
      // if right square is bigger than left square
      squares[highestSquareIdx] = rightSquare // put the right square in the last index of the result array
      right -= 1 // move right pointer to the previous element
    }
    highestSquareIdx -= 1 // decrement the result array index
  }
  return squares // return the result array
}
```

</Col>
</Row>

<Row>
  <Col>

## Triplet Sum to Zero (medium)

Given an array of unsorted numbers, find all unique triplets in it that add up to zero.

- First, we can sort the array.
- Then, we can iterate through the array, taking one number at a time.
- For every number, we can find a pair of numbers that add up to the negative of the current number.
- To do this, we can use the Two Pointers pattern.
- We can start one pointer at the beginning and one pointer at the end.
- At every step, we will see if the numbers pointed by the two pointers add up to the negative of the current number.
- If they do, we have found a triplet.
- If the numbers pointed by the two pointers add up to a number greater than the negative of the current number, we can decrement the end pointer to get a smaller number.
- If the numbers pointed by the two pointers add up to a number smaller than the negative of the current number, we can increment the start pointer to get a larger number.
- We can skip numbers while iterating to avoid duplicates.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N^2) - sorting the array will take O(N *
  logN). The searchPair() will take O(N). As we are calling searchPair() for
  every number in the input array, this means that overall searchTriplets() will
  take O(N * logN + N^2), which is asymptotically equivalent to O(N^2).
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - ignoring the space required for the
  output array, the space complexity of the above algorithm will be O(N) which
  is required for sorting.
</div>

</Col>
<Col>

```js
function search_triplets(arr) {
  arr.sort((a, b) => a - b) // sort the array
  const triplets = [] // array to store triplets
  for (let i = 0; i < arr.length; i++) {
    // iterate through the array
    if (i > 0 && arr[i] === arr[i - 1]) {
      // skip same element to avoid duplicate triplets
      continue // skip to the next iteration
    }
    search_pair(arr, -arr[i], i + 1, triplets) // search for the pair
  }
  return triplets // return the triplets
}

function search_pair(arr, target_sum, left, triplets) {
  // search for the pair
  let right = arr.length - 1 // right pointer
  while (left < right) {
    // while two pointers don't cross each other
    const current_sum = arr[left] + arr[right] // sum of the numbers pointed by the two pointers
    if (current_sum === target_sum) {
      // found the triplet
      triplets.push([-target_sum, arr[left], arr[right]]) // add the triplet to the array
      left += 1 // move left pointer to the next element
      right -= 1 // move right pointer to the previous element
      while (left < right && arr[left] === arr[left - 1]) {
        // skip same element to avoid duplicate triplets
        left += 1
      }
      while (left < right && arr[right] === arr[right + 1]) {
        // skip same element to avoid duplicate triplets
        right -= 1
      }
    } else if (target_sum > current_sum) {
      left += 1 // we need a pair with a bigger sum
    } else {
      right -= 1 // we need a pair with a smaller sum
    }
  }
}

console.log(search_triplets([-3, 0, 1, 2, -1, 1, -2])) // [-3, 1, 2], [-2, 0, 2], [-2, 1, 1], [-1, 0, 1]
console.log(search_triplets([-5, 2, -1, -2, 3])) //  [-5, 2, 3], [-2, -1, 3]
```

</Col>
</Row>


## Fast and Slow Pointers {{ className: 'text-3xl pl-2  rounded-md bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Linked List Cycle (easy)

Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

- We can use the Fast & Slow pointers method similar to **Floyd’s Cycle Detection Algorithm** to find the cycle in the LinkedList.
- We can start both pointers at the beginning of the LinkedList and traverse through the LinkedList.
- The fast pointer can move two steps while the slow pointer can move one step at a time.
- If the LinkedList has a cycle in it, the fast pointer will catch up with the slow pointer at some point.
- If the LinkedList does not have a cycle, the fast pointer will reach the end of the LinkedList.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the total number of
  nodes in the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const has_cycle = function (head) {
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next // move slow pointer one step
    fast = fast.next.next // move fast pointer two steps
    if (slow === fast) {
      // found the cycle
      return true
    }
  }
  return false
}

// Test
const head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)

console.log(`LinkedList has cycle: ${has_cycle(head)}`)
head.next.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)
head.next.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)
```

</Col>
</Row>

<Row>
  <Col>
## Palindrome Linked List (medium)

Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not.

- We can use the **Fast & Slow pointers method** to find the middle of the LinkedList.
- Once we have the middle of the LinkedList, we will reverse the second half of the LinkedList.
- Then, we will compare the first half and the reversed second half to see if they are a palindrome.
- We will have to take care of a couple of edge cases such as when the LinkedList has an even number of elements and when the length of the LinkedList is ‘1’.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the number of nodes in
  the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const is_palindromic_linked_list = function (head) {
  if (head === null || head.next === null) {
    return true
  }

  // find middle of the LinkedList
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
  }

  headSecondHalf = reverse(slow) // reverse the second half
  // store the head of reversed part to revert back later
  copyHeadSecondHalf = headSecondHalf

  // compare the first and the second half
  while (head !== null && headSecondHalf !== null) {
    if (head.value !== headSecondHalf.value) {
      break // not a palindrome
    }

    head = head.next
    headSecondHalf = headSecondHalf.next
  }

  reverse(copyHeadSecondHalf) // revert the reverse of the second half

  if (head === null || headSecondHalf === null) {
    // if both halves match
    return true
  }

  return false
}

function reverse(head) {
  let prev = null
  while (head !== null) {
    next = head.next
    head.next = prev
    prev = head
    head = next
  }
  return prev
}

// Test
const head = new Node(2)
head.next = new Node(4)
head.next.next = new Node(6)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(2)
console.log(`Is palindrome: ${is_palindromic_linked_list(head)}`) // true
head.next.next.next.next.next = new Node(2)
console.log(`Is palindrome: ${is_palindromic_linked_list(head)}`) // false
```

</Col>
</Row>


<Row>
  <Col>

## Middle of the Linked List (easy)

Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.

- If the total number of nodes in the LinkedList is even, return the second middle node.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the number of nodes in
  the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const find_middle_of_linked_list = function (head) {
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
  }
  return slow
}

// Test
const head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 3

head.next.next.next.next.next = new Node(6)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 4

head.next.next.next.next.next.next = new Node(7)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 4
```

</Col>
</Row>

## Merge Intervals {{ className: 'text-3xl pl-2  rounded-md bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Insert Interval (medium)

Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all necessary intervals to produce a list that has only mutually exclusive intervals.

- We can insert the new interval in one of the two ways:
  - **Merge the new interval with the existing intervals** if they overlap.
  - **Insert the new interval without merging** if they don’t overlap.
- We will use the **Merge Intervals** pattern to solve this problem.
- We will insert the new interval in the correct position and then merge the intervals.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the total number of
  intervals.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - as we need to return a list containing
  all the merged intervals.
</div>

</Col>
<Col>

```js
const insert = function (intervals, new_interval) {
  let merged = [],
    i = 0

  // skip and add to output) all intervals that come before the 'new_interval'
  while (i < intervals.length && intervals[i][1] < new_interval[0]) {
    merged.push(intervals[i])
    i += 1
  }

  // merge all intervals that overlap with 'new_interval'
  while (i < intervals.length && intervals[i][0] <= new_interval[1]) {
    new_interval[0] = Math.min(intervals[i][0], new_interval[0])
    new_interval[1] = Math.max(intervals[i][1], new_interval[1])
    i += 1
  }

  // insert the new_interval
  merged.push(new_interval)

  // add all the remaining intervals to the output
  while (i < intervals.length) {
    merged.push(intervals[i])
    i += 1
  }

  return merged
}

// Test
console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [1, 3],
      [5, 7],
      [8, 12],
    ],
    [4, 6]
  )}`
) // [[1,3], [4,7], [8,12]]

console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [1, 3],
      [5, 7],
      [8, 12],
    ],
    [4, 10]
  )}`
) // [[1,3], [4,12]]

console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [2, 3],
      [5, 7],
    ],
    [1, 4]
  )}`
) // [[1,4], [5,7]]
```

</Col>
</Row>
