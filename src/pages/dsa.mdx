import { Tag } from '../components/Tag'
import { UpIcon } from '../components/icons/UpIcon'

export const description =
  'In this section we will review 14 major patterns and problems used in Data Structures and Algorithms. We will also review the most common solutions to these problems and their time and space complexity.'

# Data Structures and Algorithms {{ className: 'text-3xl rounded-md pl-2 bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

In this section we will review 14 major patterns and problems used in Data Structures and Algorithms. We will also review the most common solutions to these problems and their time and space complexity.

## Table of Contents

- [Sliding Window](#sliding-window)
  - [Maximum sum subarray of size K
    <Tag variant="medium">Easy</Tag> ](#maximum-sum-subarray-of-size-k)
  - [Longest substring with `K` distinct characters
    <Tag variant="medium">Medium</Tag> ](#longest-substring-with-k-distinct-characters)
- [Two Pointers](#two-pointers)
  - [Pair with target sum
    <Tag variant="medium">Easy</Tag> ](#pair-with-target-sum)
  - [Squaring a sorted array
    <Tag variant="medium">Easy</Tag> ](#squaring-a-sorted-array)
  - [Triplet sum to zero
    <Tag variant="medium">Medium</Tag> ](#triplet-sum-to-zero)
- [Fast and Slow Pointers](#fast-and-slow-pointers)
  - [Linked List Cycle
    <Tag variant="medium">Easy</Tag> ](#linked-list-cycle)
  - [Palindrome Linked List
    <Tag variant="medium">Medium</Tag> ](#palindrome-linked-list)
  - [Middle of the Linked List
    <Tag variant="medium">Medium</Tag>](#middle-of-the-linked-list)
- [Merge Intervals](#merge-intervals)
  - [Insert Interval
    <Tag variant="medium">Medium</Tag> ](#insert-interval)
  - [Intervals Intersection
    <Tag variant="medium">Medium</Tag> ](#intervals-intersection)
  - [Conflicting Appointments
    <Tag variant="medium">Medium</Tag> ](#conflicting-appointments)
  - [Maximum CPU Load
    <Tag variant="medium">Hard</Tag>](#maximum-cpu-load)
- [Cyclic Sort](#cyclic-sort)
  - [Find the Missing Number
    <Tag variant="medium">Easy</Tag> ](#find-the-missing-number)
  - [Find the Missing Positive Number
    <Tag variant="medium">Medium</Tag> ](#find-the-missing-positive-number)
- [In-place Reversal of a LinkedList](#in-place-reversal-of-a-linkedlist)
  - [Reverse a LinkedList
    <Tag variant="medium">Easy</Tag> ](#reverse-a-linkedlist)
  - [Reverse a Sub-list
    <Tag variant="medium">Medium</Tag> ](#reverse-a-sub-list)
  - [Reverse every K-element Sub-list
    <Tag variant="medium">Medium</Tag> ](#reverse-every-k-element-sub-list)
- [Tree Breadth First Search](#tree-breadth-first-search)
  - [Binary Tree Level Order Traversal
    <Tag variant="medium">Easy</Tag> ](#binary-tree-level-order-traversal)
  - [Reverse Level Order Traversal
    <Tag variant="medium">Easy</Tag> ](#reverse-level-order-traversal)
  - [Zigzag Traversal
    <Tag variant="medium">Medium</Tag> ](#zigzag-traversal)
  - [Level Averages in a Binary Tree
    <Tag variant="medium">Easy</Tag> ](#level-averages-in-a-binary-tree)
  - [Minimum Depth of a Binary Tree
    <Tag variant="medium">Easy</Tag> ](#minimum-depth-of-a-binary-tree)
  - [Level Order Successor
    <Tag variant="medium">Easy</Tag> ](#level-order-successor)
  - [Connect Level Order Siblings
    <Tag variant="medium">Medium</Tag> ](#connect-level-order-siblings)
  - [Connect All Level Order Siblings
    <Tag variant="medium">Medium</Tag> ](#connect-all-level-order-siblings)
- [Tree Depth First Search](#tree-depth-first-search)
- [Two Heaps](#two-heaps)
- [Subsets](#subsets)
- [Modified Binary Search](#modified-binary-search)

## Sliding Window {{ className: 'text-3xl rounded-md pl-2 bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

A pattern used when given an `array` or `linked list`. Used when we need to perform a required operation on a specific window size.

<Row>
  <Col>

## Maximum sum subarray of size K

<div className="flex justify-between">
  <Tag variant="medium">Easy</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

### Description: You have an array of N positive integers and a positive integer

`num`. You have to find the Maximum Sum Subarray of size `num`.

</Col>
<Col>

```js
function maxSumSubarray(arr, num) {
  // variables
  let maxSum = 0
  let maxTemporarySum = 0

  // edge cases
  if (arr.length < num) return null

  // first loop
  for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }

  // store the first sum
  maxTemporarySum = maxSum

  // second loop
  for (let i = num; i < arr.length; i++) {
    maxTemporarySum += -arr[i - num] + arr[i]
    maxSum = Math.max(maxSum, maxTemporarySum)
  }

  // return the max sum
  return maxSum
}

console.log(maxSumSubarray([1, 2, 5, 2, 8, 1, 5], 2)) // 10
console.log(maxSumSubarray([1, 2, 5, 2, 8, 1, 5], 4)) // 17
console.log(maxSumSubarray([4, 2, 1, 6], 1)) // 6
console.log(maxSumSubarray([4, 2, 1, 6, 2], 4)) // 13

// Time Complexity: O(n)
// Space Complexity: O(1)
```

</Col>
</Row>

<Row>
  <Col>

## Longest substring with `K` distinct characters

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

### Description: Given a string you need to print longest possible substring that has exactly M unique characters. If there is more than one substring of longest possible length, then print any one of them.

Here are the steps we can take in order to solve this using the sliding window technique:

- Setup Variables
- For Loop, rightChar
- if else statement
- While Loop, leftChar
- if else, Incr start
- Calculate Max & return

</Col>
<Col>

```js
var lengthOfLongestSubstringKDistinct = function (s, k) {
  // SETUP VARIABLES
  let START = 0
  const SOFAR = new Map()
  let MAX = 0

  // ITERATE OVER s, our string, set END = 0
  for (let END = 0; END < s.length; END++) {
    // pull out our rightCHAR
    let rightCHAR = s[END]

    // if our Map does not contain the rightCHAR, then we want to set it to 1
    if (!SOFAR.get(rightCHAR)) SOFAR.set(rightCHAR, 1)
    // if it does contain the rightCHAR, then we want to increment it by 1
    else SOFAR.set(rightCHAR, SOFAR.get(rightCHAR) + 1)

    // NOW check the size (# of keys we have in SOFAR) and while it is > k
    // THEN we have to decrement the START and move it to the right one
    while (SOFAR.size > k) {
      // so lets get our leftCHAR which = s[START]
      let leftCHAR = s[START]

      //SO IF > 1 leftCHAR we want to decrement (or DELETE) followed by increment our window START
      if (SOFAR.get(leftCHAR) > 1) SOFAR.set(leftCHAR, SOFAR.get(leftCHAR) - 1)
      else SOFAR.delete(leftCHAR)

      START++
    }
    // calculate MAX using Math.max
    MAX = Math.max(MAX, END - START + 1)
  }
  // return MAX
  return MAX
}

// Test Cases
lengthOfLongestSubstringKDistinct('atatrasrafr', 3) // returns 6
lengthOfLongestSubstringKDistinct('atatrasrafr', 4) // returns 9
```

</Col>
</Row>

## Two Pointers {{ className: 'text-3xl rounded-md pl-2 bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Pair with target sum

<div className="flex justify-between">
  <Tag variant="medium">Easy</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given an array[1, 2, 3, 4, 6] with target sum:

- pointer1 points to the first element of an array, which is 1
- pointer2 points to the last element, which is 6
- First, 1 + 6 > target sum (6) so let's decrement pointer2
- Now, pointer 2 points to the second to the last element, which is 4
- Second, 1+ 4 < target sum (6) so let's increment pointer1
- Now, pointer 1 points to the second element, which is 2)
- ... so on until finding the pair which has the equal value to the target sum

</Col>
<Col>

```js
function pair_with_target_sum(arr, targetSum) {
  // pointer1 , pointing the first element
  let left = 0
  // pointer2, pointing the last element
  let right = arr.length - 1

  // until two pointers cross each other
  while (left < right) {
    const currentSum = arr[left] + arr[right]
    // returns the index (pointer1, pointer2)
    // if arr[pointer1] + arr[pointer2] == targetSum
    if (currentSum === targetSum) {
      return [left, right]
    }

    // if arr[pointer1] + arr[pointer2] < targetSum
    if (targetSum > currentSum) {
      // increment pointer1
      // we need bigger sum
      left += 1
    } else {
      // increment pointer2
      // we need smaller sum
      right -= 1
    }
  }
  // if not found, return [-1, -1]
  return [-1, -1]
}

console.log(pair_with_target_sum([1, 2, 3, 4, 6], 6))
console.log(pair_with_target_sum([2, 5, 9, 11], 11))
```

</Col>
</Row>

<Row>
  <Col>
## Squaring a sorted array
<div className="flex justify-between">
<Tag variant="medium">Medium</Tag> 
<a href="#">
  <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
</a>
</div>
Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order.

- First, we can use two pointers to iterate through the array.
- One pointer will iterate from the beginning of the array.
- The other pointer will iterate from the end of the array.
- At any step, whichever number gives us a bigger square will be added to the result array.
- As a result, the array will be sorted in the descending order.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - we are iterating the input array only
  once
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - this space will be used for the
  output array.
</div>

</Col>
<Col>

```js
function make_squares(arr) {
  const n = arr.length // length of the array
  squares = Array(n).fill(0) // create an array of n elements
  let highestSquareIdx = n - 1 // index of the last element
  let left = 0, // index of the first element
    right = n - 1 // index of the last element
  while (left <= right) {
    // while two pointers don't cross each other
    let leftSquare = arr[left] * arr[left], // square of the left element
      rightSquare = arr[right] * arr[right] // square of the right element
    if (leftSquare > rightSquare) {
      // if left square is bigger than right square
      squares[highestSquareIdx] = leftSquare // put the left square in the last index of the result array
      left += 1 // move left pointer to the next element
    } else {
      // if right square is bigger than left square
      squares[highestSquareIdx] = rightSquare // put the right square in the last index of the result array
      right -= 1 // move right pointer to the previous element
    }
    highestSquareIdx -= 1 // decrement the result array index
  }
  return squares // return the result array
}
```

</Col>
</Row>

<Row>
  <Col>

## Triplet Sum to Zero

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given an array of unsorted numbers, find all unique triplets in it that add up to zero.

- First, we can sort the array.
- Then, we can iterate through the array, taking one number at a time.
- For every number, we can find a pair of numbers that add up to the negative of the current number.
- To do this, we can use the Two Pointers pattern.
- We can start one pointer at the beginning and one pointer at the end.
- At every step, we will see if the numbers pointed by the two pointers add up to the negative of the current number.
- If they do, we have found a triplet.
- If the numbers pointed by the two pointers add up to a number greater than the negative of the current number, we can decrement the end pointer to get a smaller number.
- If the numbers pointed by the two pointers add up to a number smaller than the negative of the current number, we can increment the start pointer to get a larger number.
- We can skip numbers while iterating to avoid duplicates.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N^2) - sorting the array will take O(N *
  logN). The searchPair() will take O(N). As we are calling searchPair() for
  every number in the input array, this means that overall searchTriplets() will
  take O(N * logN + N^2), which is asymptotically equivalent to O(N^2).
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - ignoring the space required for the
  output array, the space complexity of the above algorithm will be O(N) which
  is required for sorting.
</div>

</Col>
<Col>

```js
function search_triplets(arr) {
  arr.sort((a, b) => a - b) // sort the array
  const triplets = [] // array to store triplets
  for (let i = 0; i < arr.length; i++) {
    // iterate through the array
    if (i > 0 && arr[i] === arr[i - 1]) {
      // skip same element to avoid duplicate triplets
      continue // skip to the next iteration
    }
    search_pair(arr, -arr[i], i + 1, triplets) // search for the pair
  }
  return triplets // return the triplets
}

function search_pair(arr, target_sum, left, triplets) {
  // search for the pair
  let right = arr.length - 1 // right pointer
  while (left < right) {
    // while two pointers don't cross each other
    const current_sum = arr[left] + arr[right] // sum of the numbers pointed by the two pointers
    if (current_sum === target_sum) {
      // found the triplet
      triplets.push([-target_sum, arr[left], arr[right]]) // add the triplet to the array
      left += 1 // move left pointer to the next element
      right -= 1 // move right pointer to the previous element
      while (left < right && arr[left] === arr[left - 1]) {
        // skip same element to avoid duplicate triplets
        left += 1
      }
      while (left < right && arr[right] === arr[right + 1]) {
        // skip same element to avoid duplicate triplets
        right -= 1
      }
    } else if (target_sum > current_sum) {
      left += 1 // we need a pair with a bigger sum
    } else {
      right -= 1 // we need a pair with a smaller sum
    }
  }
}

console.log(search_triplets([-3, 0, 1, 2, -1, 1, -2])) // [-3, 1, 2], [-2, 0, 2], [-2, 1, 1], [-1, 0, 1]
console.log(search_triplets([-5, 2, -1, -2, 3])) //  [-5, 2, 3], [-2, -1, 3]
```

</Col>
</Row>

## Fast and Slow Pointers {{ className: 'text-3xl pl-2  rounded-md bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Linked List Cycle

<div className="flex justify-between">
  <Tag variant="medium">Easy</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given the head of a Singly LinkedList, write a function to determine if the LinkedList has a cycle in it or not.

- We can use the Fast & Slow pointers method similar to **Floyd’s Cycle Detection Algorithm** to find the cycle in the LinkedList.
- We can start both pointers at the beginning of the LinkedList and traverse through the LinkedList.
- The fast pointer can move two steps while the slow pointer can move one step at a time.
- If the LinkedList has a cycle in it, the fast pointer will catch up with the slow pointer at some point.
- If the LinkedList does not have a cycle, the fast pointer will reach the end of the LinkedList.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the total number of nodes
  in the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const has_cycle = function (head) {
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next // move slow pointer one step
    fast = fast.next.next // move fast pointer two steps
    if (slow === fast) {
      // found the cycle
      return true
    }
  }
  return false
}

// Test
const head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
head.next.next.next.next.next = new Node(6)

console.log(`LinkedList has cycle: ${has_cycle(head)}`)
head.next.next.next.next.next.next = head.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)
head.next.next.next.next.next.next = head.next.next.next
console.log(`LinkedList has cycle: ${has_cycle(head)}`)
```

</Col>
</Row>

<Row>
  <Col>
## Palindrome Linked List

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given the head of a Singly LinkedList, write a method to check if the LinkedList is a palindrome or not.

- We can use the **Fast & Slow pointers method** to find the middle of the LinkedList.
- Once we have the middle of the LinkedList, we will reverse the second half of the LinkedList.
- Then, we will compare the first half and the reversed second half to see if they are a palindrome.
- We will have to take care of a couple of edge cases such as when the LinkedList has an even number of elements and when the length of the LinkedList is ‘1’.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the number of nodes in
  the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const is_palindromic_linked_list = function (head) {
  if (head === null || head.next === null) {
    return true
  }

  // find middle of the LinkedList
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
  }

  headSecondHalf = reverse(slow) // reverse the second half
  // store the head of reversed part to revert back later
  copyHeadSecondHalf = headSecondHalf

  // compare the first and the second half
  while (head !== null && headSecondHalf !== null) {
    if (head.value !== headSecondHalf.value) {
      break // not a palindrome
    }

    head = head.next
    headSecondHalf = headSecondHalf.next
  }

  reverse(copyHeadSecondHalf) // revert the reverse of the second half

  if (head === null || headSecondHalf === null) {
    // if both halves match
    return true
  }

  return false
}

function reverse(head) {
  let prev = null
  while (head !== null) {
    next = head.next
    head.next = prev
    prev = head
    head = next
  }
  return prev
}

// Test
const head = new Node(2)
head.next = new Node(4)
head.next.next = new Node(6)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(2)
console.log(`Is palindrome: ${is_palindromic_linked_list(head)}`) // true
head.next.next.next.next.next = new Node(2)
console.log(`Is palindrome: ${is_palindromic_linked_list(head)}`) // false
```

</Col>
</Row>

<Row>
  <Col>

## Middle of the Linked List

<div className="flex justify-between">
  <Tag variant="medium">Easy</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given the head of a Singly LinkedList, write a method to return the middle node of the LinkedList.

- If the total number of nodes in the LinkedList is even, return the second middle node.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the number of nodes in
  the LinkedList.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(1) - we only used constant space.
</div>

</Col>
<Col>

```js
class Node {
  constructor(value, next = null) {
    this.value = value
    this.next = next
  }
}

const find_middle_of_linked_list = function (head) {
  let slow = head,
    fast = head
  while (fast !== null && fast.next !== null) {
    slow = slow.next
    fast = fast.next.next
  }
  return slow
}

// Test
const head = new Node(1)
head.next = new Node(2)
head.next.next = new Node(3)
head.next.next.next = new Node(4)
head.next.next.next.next = new Node(5)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 3

head.next.next.next.next.next = new Node(6)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 4

head.next.next.next.next.next.next = new Node(7)
console.log(`Middle Node: ${find_middle_of_linked_list(head).value}`) // 4
```

</Col>
</Row>

## Merge Intervals {{ className: 'text-3xl pl-2  rounded-md bg-gradient-to-r from-[#D7EDEA] to-[#F4FBDF] opacity-100 transition duration-300 group-hover:opacity-100 dark:from-[#202D2E] dark:to-[#303428]' }}

<Row>
  <Col>

## Insert Interval

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all necessary intervals to produce a list that has only mutually exclusive intervals.

- We can insert the new interval in one of the two ways:
  - **Merge the new interval with the existing intervals** if they overlap.
  - **Insert the new interval without merging** if they don’t overlap.
- We will use the **Merge Intervals** pattern to solve this problem.
- We will insert the new interval in the correct position and then merge the intervals.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N) - where ‘N’ is the total number of
  intervals.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - as we need to return a list
  containing all the merged intervals.
</div>

</Col>
<Col>

```js
const insert = function (intervals, new_interval) {
  let merged = [],
    i = 0

  // skip and add to output) all intervals that come before the 'new_interval'
  while (i < intervals.length && intervals[i][1] < new_interval[0]) {
    merged.push(intervals[i])
    i += 1
  }

  // merge all intervals that overlap with 'new_interval'
  while (i < intervals.length && intervals[i][0] <= new_interval[1]) {
    new_interval[0] = Math.min(intervals[i][0], new_interval[0])
    new_interval[1] = Math.max(intervals[i][1], new_interval[1])
    i += 1
  }

  // insert the new_interval
  merged.push(new_interval)

  // add all the remaining intervals to the output
  while (i < intervals.length) {
    merged.push(intervals[i])
    i += 1
  }

  return merged
}

// Test
console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [1, 3],
      [5, 7],
      [8, 12],
    ],
    [4, 6]
  )}`
) // [[1,3], [4,7], [8,12]]

console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [1, 3],
      [5, 7],
      [8, 12],
    ],
    [4, 10]
  )}`
) // [[1,3], [4,12]]

console.log(
  `Intervals after inserting the new interval: ${insert(
    [
      [2, 3],
      [5, 7],
    ],
    [1, 4]
  )}`
) // [[1,4], [5,7]]
```

</Col>
</Row>

<Row>
  <Col>

## Intervals Intersection

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given two lists of intervals, find the intersection of these two lists. Each list consists of disjoint intervals sorted on their start time.

- The idea is to compare the intervals one by one and see if they overlap or not.
- If they overlap, then we need to find the overlapping part. The overlapping part will be equal to the maximum of the starting points and the minimum of the ending points.
- If the intervals overlap, then the start time of the overlapping interval will be equal to the maximum of the start time of the two intervals.
- If the intervals overlap, then the end time of the overlapping interval will be equal to the minimum of the end time of the two intervals.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(N+M) - where ‘N’ and ‘M’ are the total
  number of intervals in the input arrays respectively.
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N+M) - as we need to return a list
  containing all the intersecting intervals.
</div>

</Col>
<Col>

```js
const merge = function (intervals_a, intervals_b) {
  let result = [],
    i = 0,
    j = 0
  while (i < intervals_a.length && j < intervals_b.length) {
    // check if intervals overlap and intervals_a[i]'s start time lies within the other intervals_b[j]
    let a_overlaps_b =
      intervals_a[i][0] >= intervals_b[j][0] &&
      intervals_a[i][0] <= intervals_b[j][1]
    // check if intervals overlap and intervals_a[j]'s start time lies within the other intervals_b[i]
    let b_overlaps_a =
      intervals_b[j][0] >= intervals_a[i][0] &&
      intervals_b[j][0] <= intervals_a[i][1]
    // store the the intersection part
    if (a_overlaps_b || b_overlaps_a) {
      result.push([
        Math.max(intervals_a[i][0], intervals_b[j][0]),
        Math.min(intervals_a[i][1], intervals_b[j][1]),
      ])
    }
    // move next from the interval which is finishing first
    if (intervals_a[i][1] < intervals_b[j][1]) {
      i += 1
    } else {
      j += 1
    }
  }
  return result
}

// Test
console.log(
  `Intervals Intersection: ${merge(
    [
      [1, 3],
      [5, 6],
      [7, 9],
    ],
    [
      [2, 3],
      [5, 7],
    ]
  )}`
) // [[2,3], [5,6], [7,7]]

console.log(
  `Intervals Intersection: ${merge(
    [
      [1, 3],
      [5, 7],
      [9, 12],
    ],
    [[5, 10]]
  )}`
) // [[5,7], [9,10]]
```

</Col>
</Row>

<Row>
  <Col>

## Conflicting Appointments

<div className="flex justify-between">
  <Tag variant="medium">Medium</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

Given an array of intervals representing ‘N’ appointments, find out if a person can attend all the appointments.

- The idea is to sort the intervals by their start time.
- Then, we can iterate through the intervals to see if any two intervals overlap or not.
- Two intervals (‘a’ and ‘b’) overlap if ‘a’ starts before ‘b’ ends. i.e., `a.start < b.end`

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(NlogN) - where ‘N’ is the total number of
  appointments. We are iterating the intervals only once which will take O(N),
  in the beginning though, since we need to sort the intervals, our algorithm
  will take O(NlogN).
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - which is required for sorting.
</div>

</Col>
<Col>

```js
const can_attend_all_appointments = function (intervals) {
  intervals.sort((a, b) => a[0] - b[0])
  for (let i = 1; i < intervals.length; i++) {
    if (intervals[i][0] < intervals[i - 1][1]) {
      // please note the comparison above, it is "<" and not "<="
      // while merging we needed "<=" comparison, as we will be merging the two
      // intervals having condition "intervals[i][start] == intervals[i - 1][end]" but
      // such intervals don't represent conflicting appointments as one starts right
      // after the other
      return false
    }
  }
  return true
}

// Test
console.log(
  `Can attend all appointments: ${can_attend_all_appointments([
    [1, 4],
    [2, 5],
    [7, 9],
  ])}`
) // false

console.log(
  `Can attend all appointments: ${can_attend_all_appointments([
    [6, 7],
    [2, 4],
    [8, 12],
  ])}`
) // true

console.log(
  `Can attend all appointments: ${can_attend_all_appointments([
    [4, 5],
    [2, 3],
    [3, 6],
  ])}`
) // false
```

</Col>
</Row>

<Row>
  <Col>

## Maximum CPU Load

<div className="flex justify-between">
  <Tag variant="medium">Hard</Tag>
  <a href="#">
    <UpIcon className="h-5 w-5 flex-none fill-emerald-500 stroke-emerald-800 dark:fill-emerald-200/20 dark:stroke-emerald-200" />
  </a>
</div>

We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running. Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.

- The idea is to sort the jobs by their start time.
- Then, we can iterate through the jobs to find the maximum CPU load at any time while all jobs are running.
- While iterating, we will keep track of the maximum CPU load until the current job. To find the maximum CPU load at any time, we will take the maximum of the maximum CPU load until the previous job and the current job’s CPU load.
- While iterating, we will also keep track of the current CPU load. To find the current CPU load, we will subtract the CPU load of all the jobs that have ended by the current job’s start time.
- To find all the jobs that have ended by the current job’s start time, we can use a min-heap. Every time we are considering a job, we will add it to the min-heap. Also, before adding a new job to the min-heap, we will remove all the jobs that have ended.

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">TIME</Tag> O(NlogN) - where ‘N’ is the total number of
  jobs. We are iterating the jobs only once which will take O(N), in the
  beginning though, since we need to sort the jobs, our algorithm will take
  O(NlogN).
</div>

<div className="text-xs font-semibold text-zinc-900 dark:text-white">
  <Tag variant="medium">SPACE</Tag> O(N) - which is required for sorting. Also,
  in the worst case, we have to insert all the jobs into the min-heap (when all
  jobs overlap) which will also take O(N) space. The overall space complexity of
  our algorithm is O(N).
</div>

</Col>
<Col>

```js
const Heap = require('collections/heap')

const find_max_cpu_load = function (jobs) {
  // sort the jobs by start time
  jobs.sort((a, b) => a[0] - b[0])

  let maxLoad = 0
  let currentLoad = 0
  const minHeap = new Heap([], null, (a, b) => b[1] - a[1])
  for (let i = 0; i < jobs.length; i++) {
    const [start, end, load] = jobs[i]
    // remove all the jobs that have ended
    while (minHeap.length && minHeap.peek()[1] <= start) {
      currentLoad -= minHeap.pop()[2]
    }
    // add the current job into the minHeap
    minHeap.push(jobs[i])
    currentLoad += load
    maxLoad = Math.max(maxLoad, currentLoad)
  }
  return maxLoad
}

// Test
console.log(
  `Maximum CPU load at any time: ${find_max_cpu_load([
    [1, 4, 3],
    [2, 5, 4],
    [7, 9, 6],
  ])}`
) // 7

console.log(
  `Maximum CPU load at any time: ${find_max_cpu_load([
    [6, 7, 10],
    [2, 4, 11],
    [8, 12, 15],
  ])}`
) // 15

console.log(
  `Maximum CPU load at any time: ${find_max_cpu_load([
    [1, 4, 2],
    [2, 4, 1],
    [3, 6, 5],
  ])}`
) // 8
```

</Col>
</Row>
